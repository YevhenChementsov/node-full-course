**Читати іншими мовами: [Русский](../README.md), [English](./README.en.md).**

# Надсилання email за допомогою сервісу-посередника SendGrid.

---

Підготовка інтеграції з SendGrid API. Створення ендпоінту для верифікації email.
Додавання першого і в разі проблеми - повторного відправлення email
користувачеві з посиланням для верифікації.

---

#### Як процес верифікації має працювати

- Після реєстрації, користувач має отримати лист на вказану під час реєстрації
  пошту з посиланням для верифікації свого email.
- Пройшовши за посиланням в отриманому листі, вперше, користувач повинен
  отримати [Відповідь](#відповідь-успішної-верифікації) зі статусом `200`, що
  буде матиме на увазі успішну верифікацію email.
- Пройшовши за посиланням повторно користувач повинен отримати
  [Помилку](#помилка-повторного-надсилання-листа-верифікованому-користувачеві)
  зі статусом `400`.

---

### 1. Підготовка інтеграції з SendGrid API.

1.1. Реєстрація на [Sendgrid](https://sendgrid.com/en-us).

1.2. Створюється email відправника.

- В адміністративній панелі SendGrid зайти в меню `Marketing`.
- У підменю `Senders`, у правому верхньому кутку, натиснути кнопку
  `Create New Sender`.
- Заповнити необхідні поля в запропонованій формі. Зберегти.
- Верифікувати email, зазначений у заповненій формі.

<!-- prettier-ignore -->
1.3. Створюється API токен доступу.

- В адміністративній панелі SendGrid зайти в меню `Email API`.
- У підменю `Integration Guide` - _метод_ вибрати `Web API`, _мову_ вибрати
  `Node.js`.
- Дати ім'я токену і згенерувати його. Токен скопіювати і зберегти.

> Токен зберегти потрібно обов'язково, оскільки більше його не можна буде
> подивитися, тільки перестворити.

1.4. Отриманий API-токен додається в `.env` файл проєкту.

---

### 2. Верифікація пошти користувача.

2.1. Створюється ендпоінт для верифікації пошти.

- У модель ['User'](../models/user.js) додається два поля verificationToken і
  verify. Значення поля verify рівне false означатиме, що його email ще не
  пройшов верифікацію.

```js
// models/user.js
verify: {
  type: Boolean,
  default: false
},
verificationToken: {
  type: String,
  default: null,
}
```

- Створюється ендпоінт
  [`/api/auth/verify/:verificationToken`](#запит-верифікації), де за параметром
  verificationToken ми будемо шукати користувача в моделі
  ['User'](../models/user.js).
- Якщо користувача з таким токеном не знайдено, необхідно повернути
  [Not Found](#помилка-верифікації).
- Якщо користувач знайдений - встановлюємо verificationToken в `null`, а поле
  verify ставимо рівним `true` і повертаємо
  [Ok](#відповідь-успішної-верифікації).

##### Запит верифікації

```js
@GET /api/auth/verify/:verificationToken
```

##### Помилка верифікації

```js
Статус: 404 Not Found
Content-Type: application/json
ResponseBody: {
  "message": "User not found"
}
```

##### Відповідь успішної верифікації

```js
Статус: 200 OK
Content-Type: application/json
ResponseBody: {
	"message": "Verification successful"
}
```

---

### 3. Надсилання email користувачеві з посиланням для верифікації.

3.1 При реєстрації користувача:

- Створюється verificationToken для користувача і записується в БД (для
  генерації токена верифікації використовується пакет
  [uuid](https://www.npmjs.com/package/uuid) або
  [nanoid](https://www.npmjs.com/package/nanoid)).
- Надсилається лист на пошту користувача і вказується посилання для верифікації
  пошти (`/api/auth/verify/:verificationToken`) у повідомленні.
- Забороняється авторизація користувача при не верифікованій пошті.

---

### 4. Повторне надсилання email користувачеві з посиланням для верифікації.

Необхідно передбачити варіант, що користувач може випадково видалити лист, він
може не дійти з якоїсь причини до адресата, наш сервіс надсилання листів під час
реєстрації видав помилку тощо.

4.1 Створюється ендпоінт
[`/api/auth/verify/`](#повторне-надсилання-запиту-верифікації).

<details>
<summary>@ POST /api/auth/verify/</summary>

- Отримує `body` у форматі `{ email }`.
- Якщо в `body` немає обов'язкового поля `email`, повертає json з ключем
  `{"message": "missing required field email"}` і статусом `400`
  [Bad Request](#помилка-верифікації-повторного-надсилання-пошти).
- Якщо з `body` все добре, виконує повторне надсилання листа з verificationToken
  на вказаний email, але тільки якщо користувач не верифікований, і повертає
  json з ключем `{ "message": "Verification email sent"}` зі статусом `200`
  [Ok](#успішна-відповідь-повторного-відправлення-верифікації-пошти).
- Якщо користувач уже пройшов верифікацію, відправляє json із ключем
  `{ "message": "Verification has already been passed"}` зі статусом `400`
  [Bad Request](#помилка-повторного-надсилання-листа-верифікованому-користувачеві).

</details>

##### Повторне надсилання запиту верифікації

```js
@POST /api/auth/verify/
Content-Type: application/json
RequestBody: {
  "email": "example@example.com"
}
```

##### Помилка верифікації повторного надсилання пошти

```js
Статус: 400 Bad Request
Content-Type: application/json
ResponseBody: <Помилка від Joi або іншої бібліотеки валідації>
```

##### Успішна відповідь повторного відправлення верифікації пошти

```js
Статус: 200 Ok
Content-Type: application/json
ResponseBody: {
  "message": "The email verification link has been re-sent to your mailbox"
}
```

##### Помилка повторного надсилання листа верифікованому користувачеві

```js
Статус: 400 Bad Request
Content-Type: application/json
ResponseBody: {
  "message": "Verification has already been passed"
}
```
